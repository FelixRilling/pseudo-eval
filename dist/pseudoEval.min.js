var pseudoEval=function(n){"use strict";const t=(n,t)=>typeof n===t,u=Object,i=Map,e=n=>t(n,"undefined"),c=n=>!e(n),o=(n,t)=>c(n[t]),f=n=>e(n)||null===n,r=u.entries,s=n=>new i(r(n)),l=s({"===":(n,t)=>n===t,"!==":(n,t)=>n!==t,"&&":(n,t)=>n&&t,"||":(n,t)=>n||t,">=":(n,t)=>n>=t,"<=":(n,t)=>n<=t,">":(n,t)=>n>t,"<":(n,t)=>n<t}),a=/^(.+)(===|!==|>=|<=|>|<|&&|\|\|)(.+)$/,E=/^(.+)(\+|-|\*|\*\*|\/|%)(.+)$/,_=n=>n.substr(1,n.length-2),v=s({false:!1,true:!0,null:null}),N=/^["'`].*["'`]$/,R=n=>({val:n,success:null!==n}),p=(n,t,u=!1)=>{const i=t.split(/(?:\.|\[|\])+/g).map(n=>N.test(n)?_(n):n);let e=n;let c=null;let r=null;let s=0;for(;!f(e)&&s<i.length;){if(r=i[s],!o(e,r))return null;c=e,e=e[r],s++}if(u)return{index:s,key:r,val:e,container:c};return e},S=(n,t={},u=!1)=>R(p(t,n,u)),I=(n,t)=>{if(!isNaN(Number(n)))return R(Number(n));if(N.test(n))return R(_(n));if(v.has(n))return R(v.get(n));return R(S(n,t).val)},L=s({"+":(n,t)=>n+t,"-":(n,t)=>n-t,"*":(n,t)=>n*t,"/":(n,t)=>n/t,"%":(n,t)=>n%t,"**":(n,t)=>n**t}),g=(n,t)=>m(n,t,E,L),h=(n,t)=>{const u=n.startsWith("!");const i=u?n.substr(1):n;let e;e=a.test(i)?G(i,t):E.test(i)?g(i,t):I(i,t);u&&(e.val=!e.val);return e},m=(n,t,u,i)=>{const e=n.match(u);const c=h(e[1],t);const o=h(e[3],t);if(c.success&&o.success&&i.has(e[2])){const n=i.get(e[2]);return R(n(c.val,o.val))}return R(null)},G=(n,t)=>m(n,t,a,l);return n.evalExpression=h,n.evalLiteral=I,n.evalVariable=S,n.evalComparison=G,n.evalMath=g,n.getPathFull=p,n.getStringLiteral=_,n.mapComparison=l,n.mapMath=L,n.mapLiteral=v,n.REGEX_EXPRESSION_COMPARISON=a,n.REGEX_EXPRESSION_MATH=E,n.REGEX_GET_FUNCTION_CALL_ARGS=/(.+)\s?\((.*)\)/,n.REGEX_IS_FUNCTION_CALL=/^.+\(.*\)$/,n.REGEX_IS_STRING_LITERAL=N,n.REGEX_PATH_SPLIT=/(?:\.|\[|\])+/g,n}({});
//# sourceMappingURL=pseudoEval.min.js.map
