var pseudoEval=function(n){"use strict";const t=/^(.+)(===|!==|>=|<=|>|<|&&|\|\|)(.+)$/,u=/^(.+)(\+|-|\*|\*\*|\/|%)(.+)$/,c=(n,t)=>typeof n===t,i=Object,o=Map,e=n=>c(n,"undefined"),s=n=>!e(n),l=(n,t)=>s(n[t]),f=n=>e(n)||null===n,a=i.entries,r=n=>new o(a(n)),E=r({"===":(n,t)=>n===t,"!==":(n,t)=>n!==t,"&&":(n,t)=>n&&t,"||":(n,t)=>n||t,">=":(n,t)=>n>=t,"<=":(n,t)=>n<=t,">":(n,t)=>n>t,"<":(n,t)=>n<t}),_=n=>({val:n,success:null!==n}),v=(n,t,u,c)=>{const i=n.match(u);const o=G(i[1],t);const e=G(i[3],t);if(o.success&&e.success&&c.has(i[2])){const n=c.get(i[2]);return _(n(o.val,e.val))}return _(null)},N=(n,u)=>v(n,u,t,E),R=n=>n.substr(1,n.length-2),p=r({false:!1,true:!0,null:null}),S=/^["'`].*["'`]$/,I=(n,t,u=!1)=>{const c=t.split(/(?:\.|\[|\])+/g).map(n=>S.test(n)?R(n):n);let i=n;let o=null;let e=null;let s=0;for(;!f(i)&&s<c.length;){if(e=c[s],!l(i,e))return null;o=i,i=i[e],s++}return u?{index:s,key:e,val:i,container:o}:i},L=(n,t={},u=!1)=>_(I(t,n,u)),g=(n,t)=>_(isNaN(Number(n))?S.test(n)?R(n):p.has(n)?p.get(n):L(n,t).val:Number(n)),h=r({"+":(n,t)=>n+t,"-":(n,t)=>n-t,"*":(n,t)=>n*t,"/":(n,t)=>n/t,"%":(n,t)=>n%t,"**":(n,t)=>n**t}),m=(n,t)=>v(n,t,u,h),G=(n,c)=>{const i=n.startsWith("!");const o=i?n.substr(1):n;let e;e=t.test(o)?N(o,c):u.test(o)?m(o,c):g(o,c);i&&(e.val=!e.val);return e};return n.evalExpression=G,n.evalLiteral=g,n.evalVariable=L,n.evalComparison=N,n.evalMath=m,n.getPathFull=I,n.getStringLiteral=R,n.mapComparison=E,n.mapMath=h,n.mapLiteral=p,n.REGEX_EXPRESSION_COMPARISON=t,n.REGEX_EXPRESSION_MATH=u,n.REGEX_GET_FUNCTION_CALL_ARGS=/(.+)\s?\((.*)\)/,n.REGEX_IS_FUNCTION_CALL=/^.+\(.*\)$/,n.REGEX_IS_STRING_LITERAL=S,n.REGEX_PATH_SPLIT=/(?:\.|\[|\])+/g,n}({});
//# sourceMappingURL=pseudoEval.min.js.map
