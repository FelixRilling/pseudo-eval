var pseudoEval=function(n){"use strict";const t=/^(.+)(===|!==|>=|<=|>|<|&&|\|\|)(.+)$/,u=/^(.+)(\+|-|\*|\*\*|\/|%)(.+)$/,c=n=>({val:n,success:null!==n}),i=(n,t,u,i)=>{const o=n.match(u);const e=E(o[1],t);const l=E(o[3],t);const s=e.success&&l.success?i(e.val,o[2],l.val):null;return c(s)},o=(n,t)=>typeof n===t,e=n=>o(n,"undefined"),l=n=>!e(n),s=(n,t)=>l(n[t]),f=n=>e(n)||null===n,a=Object.entries,r=Number.isNaN,v=n=>new Map(a(n)),g=v({"===":(n,t)=>n===t,"!==":(n,t)=>n!==t,"&&":(n,t)=>n&&t,"||":(n,t)=>n||t,">=":(n,t)=>n>=t,"<=":(n,t)=>n<=t,">":(n,t)=>n>t,"<":(n,t)=>n<t}),h=(n,u)=>i(n,u,t,(n,t,u)=>g.has(t)?g.get(t)(n,u):null),b=v({"+":(n,t)=>n+t,"-":(n,t)=>n-t,"*":(n,t)=>n*t,"/":(n,t)=>n/t,"%":(n,t)=>n%t,"**":(n,t)=>n**t}),p=(n,t)=>i(n,t,u,(n,t,u)=>b.has(t)?b.get(t)(n,u):null),m=/^["'`].*["'`]$/,N=n=>n.substr(1,n.length-2),d=(n,t,u=!1)=>{const c=t.split(/(?:\.|\[|\])+/g).map(n=>m.test(n)?N(n):n);let i=n;let o=null;let e=null;let l=0;for(;!f(i)&&l<c.length;){if(e=c[l],!s(i,e))return null;o=i,i=i[e],l++}return u?{index:l,key:e,val:i,container:o}:i},$=(n,t={},u=!1)=>c(d(t,n,u)),x=v({false:!1,true:!0,null:null}),y=(n,t)=>{let u=null;u=r(Number(n))?m.test(n)?N(n):x.has(n)?x.get(n):$(n,t).val:Number(n);return c(u)},E=(n,c)=>{const i=n.startsWith("!");const o=i?n.substr(1):n;let e;e=t.test(o)?h(o,c):u.test(o)?p(o,c):y(o,c);i&&(e.val=!e.val);return e};return n.evalExpression=E,n.evalLiteral=y,n.evalVariable=$,n.evalComparison=h,n.evalMath=p,n.getPathFull=d,n.getStringLiteral=N,n}({});
//# sourceMappingURL=pseudoEval.min.js.map
