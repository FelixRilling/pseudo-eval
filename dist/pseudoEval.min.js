var pseudoEval=function(n){"use strict";const t=/^(.+)(===|!==|>=|<=|>|<|&&|\|\|)(.+)$/,u=/^(.+)(\+|-|\*|\*\*|\/|%)(.+)$/,c=n=>({val:n,success:null!==n}),e=(n,t,u,e)=>{const i=n.match(u);const o=x(i[1],t);const l=x(i[3],t);const s=o.success&&l.success?e(o.val,i[2],l.val):null;return c(s)},i=(n,t)=>typeof n===t,o=n=>i(n,"undefined"),l=n=>!o(n),s=(n,t)=>l(n[t]),f=n=>o(n)||null===n,r=Object.entries,a=Number.isNaN,v=n=>new Map(r(n)),g=v({"===":(n,t)=>n===t,"!==":(n,t)=>n!==t,"&&":(n,t)=>n&&t,"||":(n,t)=>n||t,">=":(n,t)=>n>=t,"<=":(n,t)=>n<=t,">":(n,t)=>n>t,"<":(n,t)=>n<t}),h=(n,u)=>e(n,u,t,(n,t,u)=>g.has(t)?g.get(t)(n,u):null),b=v({"+":(n,t)=>n+t,"-":(n,t)=>n-t,"*":(n,t)=>n*t,"/":(n,t)=>n/t,"%":(n,t)=>n%t,"**":(n,t)=>n**t}),p=(n,t)=>e(n,t,u,(n,t,u)=>b.has(t)?b.get(t)(n,u):null),m=/^["'`].*["'`]$/,N=n=>n.substr(1,n.length-2),d=(n,t,u=!1)=>{const c=t.split(/(?:\.|\[|\])+/g).map(n=>m.test(n)?N(n):n);let e=n;let i=null;let o=null;let l=0;for(;!f(e)&&l<c.length;){if(o=c[l],!s(e,o))return null;i=e,e=e[keyCurrent],l++}return u?{index:l,key:o,val:e,container:i}:e},y=(n,t={},u=!1)=>c(d(t,n,u)),$=v({false:!1,true:!0,null:null}),k=(n,t)=>{let u=null;u=a(Number(n))?m.test(n)?N(n):$.has(n)?$.get(n):y(n,t).val:Number(n);return c(u)},x=(n,c)=>{const e=n.startsWith("!");const i=e?n.substr(1):n;let o;o=t.test(i)?h(i,c):u.test(i)?p(i,c):k(i,c);e&&(o.val=!o.val);return o};return n.evalExpression=x,n.evalLiteral=k,n.evalVariable=y,n.evalComparison=h,n.evalMath=p,n.getPathFull=d,n.getStringLiteral=N,n}({});
//# sourceMappingURL=pseudoEval.min.js.map
