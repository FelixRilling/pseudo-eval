var pseudoEval=function(n){"use strict";const t=/^(.+)(===|!==|>=|<=|>|<|&&|\|\|)(.+)$/,e=/^(.+)(\+|-|\*|\*\*|\/|%)(.+)$/,u=n=>({val:n,success:null!==n}),i=function(n,t,e,i){const o=n.match(e),c=L(o[1],t),s=L(o[3],t),l=c.success&&s.success?i(c.val,o[2],s.val):null;return u(l)},o=(n,t)=>typeof n===t,c=n=>o(n,"undefined"),s=n=>c(n)||null===n,l=n=>!s(n)&&(o(n,"object")||o(n,"function")),a=(n,t)=>l(n)&&t in n,r=Object.entries,f=n=>new Map(r(n)),g=f({"===":(n,t)=>n===t,"!==":(n,t)=>n!==t,">=":(n,t)=>n>=t,"<=":(n,t)=>n<=t,">":(n,t)=>n>t,"<":(n,t)=>n<t,"&&":(n,t)=>n&&t,"||":(n,t)=>n||t}),p=(n,e)=>i(n,e,t,(n,t,e)=>g.has(t)?g.get(t)(n,e):null),v=f({"+":(n,t)=>n+t,"-":(n,t)=>n-t,"*":(n,t)=>n*t,"/":(n,t)=>n/t,"%":(n,t)=>n%t,"**":(n,t)=>n**t}),h=(n,t)=>i(n,t,e,(n,t,e)=>v.has(t)?v.get(t)(n,e):null),m=/^["'`].*["'`]$/,x=n=>n.substr(1,n.length-2),b=(n,t,e=!1)=>{const u=t.split(/(?:\.|\[|\])+/g).map(n=>m.test(n)?x(n):n);let i=n;let o=null;let c=null;let l=0;for(;!s(i)&&l<u.length;){if(c=u[l],!a(i,c))return null;o=i,i=i[c],l++}return e?{val:i,container:o,key:c,index:l}:i},C=(n,t={},e=!1)=>u(b(t,n,e)),d=f({false:!1,true:!0}),E=function(n,t){let e=null;return e=isNaN(Number(n))?m.test(n)?x(n):d.has(n)?d.get(n):C(n,t).val:Number(n),u(e)},L=function(n,u){const i=n.startsWith("!"),o=i?n.substr(1):n;let c;return c=t.test(o)?p(o,u):e.test(o)?h(o,u):E(o,u),i&&(c.val=!c.val),c};return n.evalExpression=L,n.evalLiteral=E,n.evalVariable=C,n.evalComparison=p,n.evalMath=h,n.getPath=b,n.getStringLiteral=x,n.mapComparison=g,n.mapLiteral=d,n.mapMath=v,n.regexExpressionComparison=t,n.regexExpressionMath=e,n.regexIsStringLiteral=m,n.regexPathSplit=/(?:\.|\[|\])+/g,n.regexIsFunction=/^.+\(.*\)$/,n.regexFunctionCallContent=/(.+)\s?\((.*)\)/,n}({});
