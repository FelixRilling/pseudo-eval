<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>pseudoEval.esm.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="Eval.html">Eval</a><ul class='methods'><li data-type='method'><a href="Eval.html#.evalComparison">evalComparison</a></li><li data-type='method'><a href="Eval.html#.evalExpression">evalExpression</a></li><li data-type='method'><a href="Eval.html#.evalLiteral">evalLiteral</a></li><li data-type='method'><a href="Eval.html#.evalMath">evalMath</a></li><li data-type='method'><a href="Eval.html#.evalVariable">evalVariable</a></li></ul></li><li><a href="Get.html">Get</a><ul class='methods'><li data-type='method'><a href="Get.html#.getPathFull">getPathFull</a></li><li data-type='method'><a href="Get.html#.getStringLiteral">getStringLiteral</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">pseudoEval.esm.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { mapFromObject, isNil, hasKey } from 'lightdash';

/**
 * Regex for comparisons
 *
 * @private
 * @memberof EvalRegex
 */
const REGEX_EXPRESSION_COMPARISON = /^(.+)(===|!==|>=|&lt;=|>|&lt;|&amp;&amp;|\|\|)(.+)$/;

/**
 * Regex for math
 *
 * @private
 * @memberof EvalRegex
 */
const REGEX_EXPRESSION_MATH = /^(.+)(\+|-|\*|\*\*|\/|%)(.+)$/;

/**
 * Utility function for returns
 *
 * @private
 * @param {any} val
 * @returns {Object}
 */
const wrapResult = (val) => {
    return {
        val,
        success: val !== null
    };
};

/**
 * Generic routine for the ternary a,op,b regex matching
 *
 * @private
 * @param {string} str
 * @param {Object} ctx
 * @param {RegExp} regex
 * @param {Map&lt;string,function>} map
 * @returns {Object}
 */
const ternaryRoutine = (str, ctx, regex, map) => {
    const match = str.match(regex);
    const a = evalExpression(match[1], ctx);
    const b = evalExpression(match[3], ctx);
    if (a.success &amp;&amp; b.success &amp;&amp; map.has(match[2])) {
        const fn = map.get(match[2]);
        return wrapResult(fn(a.val, b.val));
    }
    else {
        return wrapResult(null);
    }
};

/**
 * Map for comparison checks
 *
 * @private
 * @memberof EvalMap
 */
const mapComparison = mapFromObject({
    "===": (a, b) => a === b,
    "!==": (a, b) => a !== b,
    "&amp;&amp;": (a, b) => a &amp;&amp; b,
    "||": (a, b) => a || b,
    ">=": (a, b) => a >= b,
    "&lt;=": (a, b) => a &lt;= b,
    ">": (a, b) => a > b,
    "&lt;": (a, b) => a &lt; b
});

/**
 * Evaluates an comparison
 *
 * @function evalComparison
 * @memberof Eval
 * @param {string} str
 * @param {Object} ctx
 * @returns {Object}
 */
const evalComparison = (str, ctx) => ternaryRoutine(str, ctx, REGEX_EXPRESSION_COMPARISON, mapComparison);

/**
 * Map for math checks.
 *
 * @private
 * @memberof EvalMap
 */
const mapMath = mapFromObject({
    "+": (a, b) => a + b,
    "-": (a, b) => a - b,
    "*": (a, b) => a * b,
    "/": (a, b) => a / b,
    "%": (a, b) => a % b,
    "**": (a, b) => a ** b
});

/**
 * Evaluates an comparison
 *
 * @function evalMath
 * @memberof Eval
 * @param {string} str
 * @param {Object} ctx
 * @returns {Object}
 */
const evalMath = (str, ctx) => ternaryRoutine(str, ctx, REGEX_EXPRESSION_MATH, mapMath);

/**
 * Regex checking for string literals
 *
 * @private
 * @memberof EvalRegex
 */
const REGEX_IS_STRING_LITERAL = /^["'`].*["'`]$/;

/**
 * Returns a string literal as "normal" string
 *
 * @function getStringLiteral
 * @memberof Get
 * @param {string} str
 * @returns {string}
 */
const getStringLiteral = (str) => str.substr(1, str.length - 2);

/**
 * Regex for splitting paths
 *
 * @private
 * @memberof EvalRegex
 */
const REGEX_PATH_SPLIT = /(?:\.|\[|\])+/g;

/**
 * Accesses a target by a path of keys. If the path doesn't exist, null is returned
 *
 * @function getPathFull
 * @memberof Get
 * @param {any} target
 * @param {string} path
 * @param {boolean} [getContaining=false]
 * @returns {any|null}
 */
const getPathFull = (target, path, getContaining = false) => {
    const pathArr = path
        .split(REGEX_PATH_SPLIT)
        .map((item) => REGEX_IS_STRING_LITERAL.test(item)
        ? getStringLiteral(item)
        : item);
    let targetCurrent = target;
    let targetLast = null;
    let key = null;
    let index = 0;
    while (!isNil(targetCurrent) &amp;&amp; index &lt; pathArr.length) {
        key = pathArr[index];
        if (hasKey(targetCurrent, key)) {
            targetLast = targetCurrent;
            targetCurrent = targetCurrent[key];
            index++;
        }
        else {
            return null;
        }
    }
    if (getContaining) {
        return {
            index,
            key,
            val: targetCurrent,
            container: targetLast
        };
    }
    else {
        return targetCurrent;
    }
};

/**
 * Evaluates an variable
 *
 * @function evalVariable
 * @memberof Eval
 * @param {string} str
 * @param {Object} [ctx={}]
 * @param {boolean} [getContaining=false]
 * @returns {Object}
 */
const evalVariable = (str, ctx = {}, getContaining = false) => wrapResult(getPathFull(ctx, str, getContaining));

/**
 * Map for literal checks.
 *
 * undefined and NaN are omitted because you usually wont need those
 *
 * @private
 * @memberof EvalMap
 */
const mapLiteral = mapFromObject({
    false: false,
    true: true,
    null: null
});

/**
 * Evaluates a literal
 *
 * @function evalLiteral
 * @memberof Eval
 * @param {string} str
 * @param {Object} ctx
 * @returns {Object}
 */
const evalLiteral = (str, ctx) => {
    if (!isNaN(Number(str))) {
        return wrapResult(Number(str));
    }
    else if (REGEX_IS_STRING_LITERAL.test(str)) {
        return wrapResult(getStringLiteral(str));
    }
    else if (mapLiteral.has(str)) {
        return wrapResult(mapLiteral.get(str));
    }
    else {
        return wrapResult(evalVariable(str, ctx).val);
    }
};

/**
 * Evaluates an str
 *
 * @function evalExpression
 * @memberof Eval
 * @param {string} str
 * @param {Object} ctx
 * @returns {Object}
 */
const evalExpression = (str, ctx) => {
    const isInverted = str.startsWith("!");
    const strSub = isInverted ? str.substr(1) : str;
    let result;
    if (REGEX_EXPRESSION_COMPARISON.test(strSub)) {
        result = evalComparison(strSub, ctx);
    }
    else if (REGEX_EXPRESSION_MATH.test(strSub)) {
        result = evalMath(strSub, ctx);
    }
    else {
        result = evalLiteral(strSub, ctx);
    }
    if (isInverted) {
        result.val = !result.val;
    }
    return result;
};

/**
 * Regex for function call args
 *
 * @private
 * @memberof EvalRegex
 */
const REGEX_GET_FUNCTION_CALL_ARGS = /(.+)\s?\((.*)\)/;

/**
 * Regex checking for function calls
 *
 * @private
 * @memberof EvalRegex
 */
const REGEX_IS_FUNCTION_CALL = /^.+\(.*\)$/;

/**
 * String evaluation
 * @namespace Eval
 */
/**
 * Data retrieval
 * @namespace Get
 */
/**
 * Maps used internally for evaluation
 * @private
 * @namespace EvalMap
 */
/**
 * RegExp used internally for evaluation
 * @private
 * @namespace EvalRegex
 */

export { evalExpression, evalLiteral, evalVariable, evalComparison, evalMath, getPathFull, getStringLiteral, mapComparison, mapMath, mapLiteral, REGEX_EXPRESSION_COMPARISON, REGEX_EXPRESSION_MATH, REGEX_GET_FUNCTION_CALL_ARGS, REGEX_IS_FUNCTION_CALL, REGEX_IS_STRING_LITERAL, REGEX_PATH_SPLIT };
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.0-dev</a> on Sat Feb 03 2018 14:06:31 GMT+0100 (CET) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
